# 面向对象分析

![image-20231108085424736](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108085424736.png)

- 对应需求工程中的需求分析步骤
- 处理的是需求是什么，what的问题；不是如何实现，how的问题

## 面向对象方法

将程序结构抽象为一组对象用以指导程序设计

![image-20231108092927423](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108092927423.png)

这里是第一步，面向对象分析

### **对象**

对象是用于代表实际概念，实体等物体的对象

![image-20231108093025165](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093025165.png)

![image-20231108093042575](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093042575.png)

- 抽象：定义实体区别于其他实体的属性

  ![image-20231108093206663](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093206663.png)

- 概括：隐藏实现的复杂性，只给用户提供接口

  ![image-20231108093259051](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093259051.png)

- 模块化：通过合理的分解软件结构，使得整体的实现能够通过各个模块以及他们之间的协作来理解

  ![image-20231108093308839](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093308839.png)

- hierarchy：根据不同的抽象程度组织分层结构

  ![image-20231108093428320](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093428320.png)

### 类

类代表一类对象，而属于某一个类的对象即是其实例

![image-20231108093730880](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093730880.png)

### 包

包对一个子模块进行概括，将整个复杂的系统简化为各个包之间的关系。

![image-20231108093938662](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093938662.png)

![image-20231108093948927](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108093948927.png)

## 面向对象分析

- 希望能够获得PIM
- 对应用例图、时序图、活动图、类图、通信图、包图等
- ![image-20231108094126188](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108094126188.png)

**UML**：一种面向对象设计的建模工具，定义了各个面向对象分析标准

### 用例建模

#### 用例图

描述一组外部世界的对象与系统之间的交互以及系统对这些交互的反应

![image-20231108100243151](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108100243151.png)

基本元素包括：

1. 执行者Actor：与系统交互的实体
2. 用例Use Case：代表执行者希望系统能做的事
3. 关系：包括各个要素之间的关系，关系分为三种类型：包含，扩展，泛化

#### 用例分析的过程

其实就是建立用例图，优化其结构以及设计用例规约的过程

##### 1.识别Actor和Use Case，画出用例图

![image-20231108100811417](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108100811417.png)

可以通过下面这些角度来寻找他们：

![image-20231108100833739](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108100833739.png)

![image-20231108100840642](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108100840642.png)

需要注意的是：

- 一个用例所定义的是系统和Actor之间的一次完整的交互。也就是说不能将一次交互划分为多个用例。在这次交互中可能存在很多步骤，但是对于Actor来说就是系统在执行它所需求的这件事情，这个才是对应的用例。
- 用例的粒度。某些用例可能构成用户使用系统的一次交互，但却并不能代表用户本次使用系统的目的，如“登录”+“查询”+“修改”，其实用户的目的就是修改，那么这个用例就应该是“修改“。
- 用例的描述：不应该涉及数据操作等低层次细节，应该从用户的角度来描述用例

**识别了Actor和Use Case之后，应该通过找到他们之间的关联画出用例图**

![image-20231108101729660](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108101729660.png)

这个阶段的用例图包含：

- 主要执行者：他们从系统获得价值，如用户
- 次要执行者：他们为系统提供服务，如后台服务器
- 执行者和用例之间的关系：如果用例的粒度正确，那么执行者能够通过一个用例就可以达成目标，每个用例都有对应的一个或多个主要执行者

##### 2.用例规约的撰写

用例规约用于说明系统在执行用例的过程中做了什么，需要用户和系统做什么样的交互。但是由于这是PIM，用例规约应该从用户的角度撰写，并且不包括任何实现上的细节。

![image-20231108102513789](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108102513789.png)

描述”用例在做什么“的基本工具是事件流和活动图

**事件流**

由用户和系统进行交互时的一系列动作组成

![image-20231108102746161](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108102746161.png)

- 基本流：一次正常的交互应该包括的一系列动作
- 备选流：出现特殊情况时的事件流，如查询失败或者不常用的情况

一个UseCase的实例即是一次真实的与系统的交互，称为Senario，它也是一个可能出现的事件流

![image-20231108103256957](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108103256957.png)

实际的事件流除了简单的”谁干什么“之外其实还有对于每个步骤的详细描述

![image-20231108103506266](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108103506266.png)

![image-20231108103537797](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108103537797.png)

对于在某些条件下触发的事件流需要进行说明

![image-20231108103834156](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108103834156.png)

对于可以在多个基本流步骤下出现的备选流，可以用1-3a、2，9，4-7a这样的方法进行标号

**活动图**

当事件流包含较多的逻辑关系时，使用事件流的表述会包括大量的备选流，可读性很差。此时可以使用时序图或者活动图的方法，将每个事件流动作表述为一个活动

![image-20231108104148733](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108104148733.png)

![image-20231108104245979](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108104245979.png)

包含根据执行者身份划分的活动图（这是因为在一个用例中有多个执行者参与）

**前置条件**

![image-20231108104340996](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108104340996.png)

**后置条件**

![image-20231108104358783](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108104358783.png)

**其他**

![image-20231108104417141](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108104417141.png)

##### 3.优化用例图的结构

之前的用例基于用户的交互需求，然而这些需求之间可能存在关系，通过寻找这些关系可以达成用例的复用，具有更好的易用性等

![eb58dc5859b2b13d9cd709c9be3b972](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/eb58dc5859b2b13d9cd709c9be3b972.jpg)

可以看到，优化后的用例图

1. 仍然包括之前的用例
2. 有一些用例从原来的用例中提取出来，包含于各个用例之中；这是包含
3. 有一些用例从原来的用例中总结出来；这是泛化
4. 有一些用例从原来的用例中的可选功能中拓展出来；这是扩展

这些多出来的用例都来源于开始的用例，能够提高可复用性，或者使用例的作用更明确

1. **包含**

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105357014.png" alt="image-20231108105357014" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105404535.png" alt="image-20231108105404535" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105412017.png" alt="image-20231108105412017" style="zoom:50%;" />

2. **扩展**

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105623973.png" alt="image-20231108105623973" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105640659.png" alt="image-20231108105640659" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108105804393.png" alt="image-20231108105804393" style="zoom:50%;" />

   在Get Quote时，在选择Optional Service这一步通过选择Get News或Get Exp能够扩展到这两个用例。他们通过两个次要执行者的支持为主要执行者提供扩展服务。注意箭头的指向代表”从XX扩展“

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108110000480.png" alt="image-20231108110000480" style="zoom:50%;" />

3. **泛化**

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108111222345.png" alt="image-20231108111222345" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108111236106.png" alt="image-20231108111236106" style="zoom:50%;" />

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108111307989.png" alt="image-20231108111307989" style="zoom:50%;" />

   可以看到，在父类中只有对这一步简单的描述而没有实际的动作，子类中才把具体做什么说清楚

   执行者之间也有泛化关系

   <img src="https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231108111325341.png" alt="image-20231108111325341" style="zoom:50%;" />

   

   

