# 面向对象设计

架构设计基于需求工程（面向对象分析）解决了软件整体结构的问题，而面向对象设计则是更进一步，指导各个部分具体的实现

![image-20231121154220010](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121154220010.png)

## 面向对象设计的原则

![image-20231121154343292](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121154343292.png)

![image-20231121154730160](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121154730160.png)

就是说如果类T负责A和B两个不同的职责的时候，对这两个职责各自的修改都会影响到类的实现，并且潜在的存在干扰其另一个负责的职责。因此，希望能够尽量减少一个类的职责。

![image-20231121154925848](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121154925848.png)

其实说的就是子类型必须要具有所有基类型所提供的特性

![image-20231121155105985](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121155105985.png)

指的是高层次的模块依赖于一系列接口，这些接口不是由下层提供的而是被高层所需要的。下层的实现即是在实现这些接口。这样一来高层和底层之间就被解耦了

![image-20231121155420915](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121155420915.png)

一个低内聚的接口可能导致其提供的部分功能永远不会被客户使用。此时需要将它分解为多个接口

![image-20231121155502379](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121155502379.png)

![image-20231121155512561](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121155512561.png)

![image-20231121155759701](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121155759701.png)

- 在复用时希望多采用组合/聚合的方法
- 继承会导致耦合程度的增加
- ![image-20231121160333505](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121160333505.png)

![image-20231121160344085](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121160344085.png)

![image-20231121160453698](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121160453698.png)

## 设计模式

![image-20231121160623800](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121160623800.png)

### 创建型模式

#### 工厂方法

![image-20231121162602247](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121162602247.png)

- 所有的具体工厂类都继承于抽象工厂类，这使得他们都具有和抽象工厂类相同的接口（在某些情况下，还包括一些所有具体工厂类共享的部分实现）
- 当实际需要一个product的时候，通过具体的工厂来创建。此时使用的接口和抽象工厂中定义的相同，但是接口的具体实现是在具体工厂中的
- 抽象工厂关注的是如何统一一组有内聚的类的创建过程
- 通过这样的方法能够实现较好的解耦，客户基于抽象工厂和抽象产品编程

![image-20231121163622192](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121163622192.png)

![image-20231121163726479](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121163726479.png)

#### 抽象工厂

![image-20231121163821016](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121163821016.png)

- Client同时需要一组关联的对象（ProductA，ProductB），而不同的Client需要不同的product，因此采用数个具体工厂来负责这些不同的Client所需要的几组不同的对象
- Client只需要针对抽象对象即可，根据其类型调用不同的Factory就能得到对应的对象
- 和工厂方法相比，抽象工厂关注于创建逻辑上相关的一组类，实际上如果ProductA1和ProductA2的创建过程中有相似之处，也可以采用工厂方法来实现两个具体工厂中的CreateProductA方法

![image-20231121164941511](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121164941511.png)

- 如果新加了一个抽象产品，那么工厂接口和具体工厂的实现都要进行修改

![image-20231121165217757](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231121165217757.png)

#### 建造者模式

研究的是构造具体对象的方法。有时多个对象具有相同的构建过程