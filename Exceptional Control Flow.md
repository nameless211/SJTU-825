# Exceptional Control Flow

## Outline

- 异常
  - 异常的种类
  - 异常处理
- 进程
  - 逻辑流和并发
  - 进程的基础
    - 私有地址空间
    - 用户态和内核态、context switch
  - 进程控制
    - 创建，中止，回收进程
    - 程序的运行
- 信号
  - 基本过程
  - 发送和接收信号
  - 处理信号、并发问题
- 非本地跳转

## 异常

![image-20231023144418877](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023144418877.png)

当一个事件发生（可能是由于程序的执行或者是外部信号等），处理器检测到事件，并且通过异常的方式“接管”执行流，对异常进行处理后再返回

P502有详细过程

### 异常处理

1. CPU检测到发生了一个事件，并且确认其对应的异常号
2. CPU触发异常，通过间接过程调用，根据异常号索引到异常表中的对应异常处理程序
3. 处理程序结束后，可选地返回到对应被中断执行地程序，并将控制和数据恢复

**索引过程**

![image-20231023145952105](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023145952105.png)

- 异常表中每一个条目都是一块异常处理函数的起始地址，只要能通过异常号找到对应的异常表条目，就能通过间接过程调用（就是直接跳转到一块地址上，并且将它的内容当成函数来执行）运行处理函数

- 异常表在计算机的启动阶段进行初始化，在各个条目中填上对应地址

- ![image-20231023150236259](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023150236259.png)

  异常号*8（64位系统）再加上异常表基地址寄存器中存储的异常表的起始地址，就能找到对应的项

根据异常处理的过程，实际上比较类似于函数调用，执行流转换到另一个程序，执行后再返回继续执行原先的程序，但是它也有不同之处：

1. 异常处理的返回地址可能是程序的下一条或本条指令
2. 在间接过程调用时可能会将部分处理器状态压入栈中
3. 异常处理程序总是运行在内核态下。如果被中断的函数是用户态函数，那么它的状态会被压入内核栈，并进行context switch

### 异常的类型

![image-20231023150822907](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023150822907.png)

一共有四类异常，主要注意其诱因和返回行为

*在这里同步指异常由某一条指令导致，异步指任何时候都可能发生，和特定的指令无关

#### 中断

![image-20231023151427527](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023151427527.png)

![image-20231023151459222](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023151459222.png)

- 通过中断引脚的高电平来通知CPU
- 许多中断的处理程序（如DMA）只是发起了一个请求，而实际的处理程序在中断返回后继续运行，和CPU的指令并行，在这个意义上也是异步的

#### trap&syscall

- 通过一条指令主动发起
- 针对用户程序需要请求敏感功能（read，execve等），又需要和内核隔离设计的特殊调用，称syscall
- syscall所调用的函数处在内核态，能够访问内核栈以及执行特殊指令

#### fault

- fault由错误情况引起，而这个错误情况可能是由一条指令引起（如引用虚拟地址导致缺页异常）
- 异常处理程序会尝试修复这个错误情况
- 如果修复成功，会重新执行那条引起错误的指令
- 失败则直接终止（返回到内核态中的abort例程从而终止程序运行）

#### 终止

无法修正的错误，直接返回到abort例程，终止程序运行。

### Linux/x86-64异常实例

- 异常表中有CPU定义的（除零，缺页等）和操作系统定义的（syscall等）两种异常
- linux系统调用的传参和普通函数不同
- 和call \<function name>不同，linux系统调用将对应异常号放入%rax寄存器，然后直接执行syscall指令即可

## 进程

![image-20231023144230874](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231023144230874.png)

操作系统建立在三大基本抽象上，而本章进程即是基本抽象之一，通过进程来管理CPU资源和程序权限

