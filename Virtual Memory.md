# Virtual Memory

## Outline

1. 虚拟内存机制
   - 虚拟地址空间
   - 寻址模式
     - 页表
     - 地址翻译
2. 虚拟内存的应用
   - 内存映射
   - 动态内存分配
   - garbage collection

## 虚拟内存机制

- 虚拟内存为CPU提供一个建立在物理内存之上的地址空间，这个地址空间是一个连续的数组，以虚拟页为单位。
- 对虚拟内存的访问可以被映射为对物理内存的访问，从而将对物理内存的管理和对虚拟内存的使用相隔离

于是虚拟内存的机制实际上就是维护虚拟内存和物理内存之间的映射关系的方法

### 页表

![image-20231030152954699](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231030152954699.png)

- 在这里，由于每个进程拥有独立的地址空间，因此每个进程都拥有自己的页表
- 通过虚拟内存地址映射到对应页表项，从而能够获取对应的物理页，从而访问对应的物理内存地址
- 有些页表项是空的，这是由于虚拟内存地址空间一般都大于实际的物理内存，而绝大多数程序都不会使用这么大的地址空间，因此只分配那些程序所需要的地址空间即可。也就是说只有程序可能访问到的那些虚拟地址才有它们的对应映射

### 页表机制

首先我们忽略具体机制，考察寻找虚拟内存地址对应的页表项和根据页表项寻找物理页的过程。

**页命中**

最简单的情况，当CPU试图访问一个有对应页表项的虚拟内存地址时。

- 虚拟内存地址被翻译为页表索引，从而找到对应页表项
- 通过对应页表项的地址定位物理内存地址

**页不命中**

实际上CPU通过查询VMA来确定虚拟内存地址是否合法。对于不合法的情况，即访问了未被分配的内存地址，产生Segmentation Fault。对于合法的情况（page fault，缺页异常），有两种可能：

1. 由于物理内存不足，该虚拟页被暂时换出到磁盘上
2. 由于按需分配机制，该页被分配之后还未映射到物理页

根据情况不同，触发对应的机制

### 地址翻译

![image-20231030160759181](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231030160759181.png)

虚拟内存空间：$N=2^n$

物理内存空间：$M=2^m$

页大小：$P=2^p$

因此我们需要的映射如下

![image-20231030160939975](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231030160939975.png)

- 后p位为页offset，保持不变
- 前面的位经过映射对应

而这个翻译的过程由MMU利用页表机制实现

![image-20231030161212060](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231030161212060.png)

- 通过页表基地址寄存器指向页表的起始地址（这是一个物理地址）
- 通过虚拟内存地址的前几位找到对应的页表项，简单的方法是直接通过其unsigned数值得到
- 通过页表项找到物理地址

而如果产生缺页异常，会下陷到缺页异常处理程序，将对应物理页换入主存或添加对应页表项。之后重新执行导致缺页异常的程序，此时就能正常找到对应页表项。

**和高速缓存结合**

建立在物理内存上的高速缓存机制能很好的和这套体系结合。

翻译过程中，存在两次读物理内存，一次是对页表，一次是获取对应数据。只需要将这两次访问都先在高速缓存中进行查找即可，甚至完全不需要修改MMU。

但是对于页表来说，一方面是内存访问操作太过频繁，页表会严重挤占其他数据的空间；其次，就算是高速缓存机制所提供的访问加速也无法满足页表查询的需求，因此引入了TLB机制。

![image-20231030162411686](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231030162411686.png)

### 页表架构

对于单个页表而言，它所映射的只能是一片连续的虚拟内存空间。举例来说，为了给程序提供一个32位的地址空间，页表中需要包含这个地址空间中所有虚拟页的映射。

一个简单的想法是只映射进程中对应结构的内存空间，类似分段机制。这种机制使用多个页表，可以不用将所有内存空间都映射上，只包含那些需要被应用申请的空间。

但是问题是，一个空间在被申请后并不总是马上被使用，在这种链状的页表架构中，凡是被申请的空间就已经产生了页表的空间占用。另外，由于VA到PTE的寻址采用的是直接的数值映射，这种不定长的页表结构在寻址上会产生相当大的麻烦

因此，实际的页表采用多级架构

![image-20231101094836547](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101094836547.png)

- 大量的未被分配的地址空间对应的页表项是在一级页表中，占用很小
- 页表中PTE查询直接采用数值方式，找到下一级页表，也是直接采用数值方式，很方便（虽然性能相比一整张会有数倍的差距）
- 不用把整张页表都缓存在主存中，对页表的管理可以以低级页表为粒度

![image-20231101095303288](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101095303288.png)

直接找到对应字段的数值即可进行寻址

### TLB

由于每次地址查询实际上都涉及两次内存访问，这相当于一次内存访问就需要额外的一次开销（cold情况），对于多级页表更甚，对于一个四级页表的结构，需要五次内存访问。这是难以接受的。因此，对于页表项有专门的高速缓存机制来加速内存访问，这就是TLB。

TLB是MMU中的一块缓存，采用VPN（虚拟页号，即VA前几位）作为索引，结构和普通的缓存类似

![image-20231101102056301](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101102056301.png)

通过TLB找到对应的物理页号之后，就可以通过VA后面的offset找到对应的数据了

![image-20231101102418843](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101102418843.png)

![image-20231101102429220](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101102429220.png)

### 案例

P573 地址翻译案例

P576 i7/Linux上的实例

i7

- CR3
- 限制可执行代码区域
- 页替换相关

Linux

- memory layout
- VMA、分段机制
- 缺页异常的处理过程

## 虚拟内存应用

虚拟内存能够：

- 利用较小的物理内存空间来支持较大的虚拟内存空间
- 将不同的进程的内存空间分离开，同时提供共享内存的机制

这分别对应着动态内存分配以及内存映射的机制

### 内存映射

#### 通过映射来初始化虚拟内存空间

- 通过映射到文件系统中的内容，可以将虚拟内存空间初始化为文件内容
- 通过映射到匿名文件（由内核创建的全部是二进制0的文件），将虚拟内存空间初始化为0。但是实现上这个过程并不包含数据传送（P582）

当需要换页时，换出的页会被存储到一块“交换空间”中，成为“交换文件”。所有通过映射请求的页一开始都是存储在磁盘上的，只有当被访问的时候才被存储到内存中。这个过程被称为“on demand paging”

这里需要区分一些概念：

1. 磁盘上的文件：所有内存中的数据都是从磁盘中读取的，可以说在进程操作磁盘中的数据之前需要在内存中生成一个相应的对象
2. 共享区域，私有区域：通过将磁盘中的数据映射到物理内存，产生了共享和私有的区域。然而这个权限却和是不是同一份磁盘数据无关。

对于共享对象而言，理所当然的在内存中只会有一份它的副本，并且被映射到两个不同的进程的虚拟内存空间中。

对于私有对象而言，采用copy-on-write的策略，只要使用它的进程没有对其做修改操作，这部分内容就是共享的。

![image-20231101191913256](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101191913256.png)

对于被修改的内容，对应进程单独拷贝一份，并进行修改。这个修改就是私有的。

#### fork

fork的两个进程具有相同的地址空间，但是之后的修改却是互相独立的。这基于：

1. fork之后，两个进程都将虚拟内存空间中的数据结构映射到原本的物理内存
2. 这一部分页表被标记为只读，而区域被标记为私有的copy-on-write，这样一来它们试图写时会触发异常，从而在处理时对这部分进行拷贝并恢复可写权限

#### execve

执行时需要加载大量的数据结构，因为会重新设置进程，替代之前进程中所执行的程序（并且不会返回）

![image-20231101192709412](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101192709412.png)

1. 首先释放之前进程的页表映射
2. 重新创建各个数据结构的VMA以及页表

在这个过程中，代码段、数据段采用的就是私有的copy-on-write方法，而其他共享数据（如标准库函数）等则映射到共享区域。栈和堆都是请求的匿名区域

**mmap**

![image-20231101193110583](https://markdown-zyy.obs.cn-east-3.myhuaweicloud.com/img/image-20231101193110583.png)

mmap函数分配一块希望（在不被占用时）从start开始的虚拟内存区域，映射到fd指定的文件中offset开始的len个字节

prot设置访问权限，flag设置对象类型（共享，匿名等）

**mumap**

删除

### 动态内存分配

**堆：**进程数据结构中的一个部分，用于保存一个进程的虚拟内存区域。堆由一系列内存块组成，它们是空闲的或者已分配的。

管理堆中内存分配的程序即是动态内存分配器，它分两种：

1. 显式分配器：要求应用显式地释放分配过的块
2. 隐式分配器：不需要释放，分配器自己会检测并释放不需要的块，也叫垃圾收集器

简单的说，分配器的工作就是：寻找有没有适合的空闲块，如果没有的话就扩张堆的大小，并在扩张的部分中分配空间。

这个过程中有以下问题：

1. 分配后又释放的块可能导致外部碎片问题。这些碎片会使得堆中连续的内存空间减小，导致可能堆中有足够的空间却无法分配内存，只有扩张堆。

2. 为了对齐或实现分配策略，块中可能有部分区域并没有存储数据或者存储的是元数据。这些空间被称为内部碎片

3. 总的一个堆在一个长度为k的请求后的使用效率被定义为
   $$
   U_k=\frac{max_{i\leq k}P_i}{H_k}
   $$
   $H_k$为堆的大小，其是单调递增的；$max_{i\leq k}P_i$为在所有请求序列执行过程中最大的已分配有效载荷（指令所请求的所有内存的大小之和）。

4. 分配器的目标即是最大化$U_k$

#### malloc、sbrk、free

#### 隐式空闲链表

#### 实例

#### 其他内存分配器

### 总结

通过这些机制，虚拟内存允许：

- 所有进程拥有类似的memory layout，从而简化了链接器生成可执行文件的步骤
- 简单的文件映射：不需要将文件实际拷贝到内存，只需要将一个虚拟页标记为换出到磁盘，并且指向文件内容即可。在访问这个虚拟页的时候虚拟内存会自动地调入内存。
- 共享和保护：每个进程拥有自己地页表，通过一张页表只能访问对应有映射的内存空间，这保证了独立性。而通过将两张页表中的页表项指向同一个物理页，能够实现物理页的共享，还能通过copy-on-write等机制保证一致性。通过设置不同进程中的页表项，可以实现对共享页每个进程独有的访问权限
- 内存分配：虚拟内存将实际的物理内存分配和进程所使用的内存相分离。进程使用的可以是连续的虚拟内存空间，而实际分配的物理内存可以是完全分散，由分配器自行决定的。



